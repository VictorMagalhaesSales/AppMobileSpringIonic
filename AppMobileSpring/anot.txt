								|| App Mobile Hibrido com Spring  ||

========== Módulo 2: implementação do modelo conceitual ========== 

 - No relacionamento Muitos para Muitos, temos que adicionar a anotação @ManyToMany nas duas entidades, sendo em uma com o mappedBy, e na outra com o @JoinTable(nome, colunas = a , b);
 - @JsonManagedReference e @JasonBackReference resolve um problema de serialização(referência) cíclica entre duas entidades que se referenciam. A primeira anotação define qual entidade vai serializar a outra, enquanto a segunda define qual entidade não vai serializar(OBS: no final do módulo, o autor tira a primeira anotação e substitui a segunda por @JsonIgnore, elas estavam resultando em erros nos CRUDS, por algum motivo);
 - Nas associações bidirecionais, usaremos o @JoinColumn('') em na entidade que recebe a chave extrangeira para personalizar o seu nome, enquanto na outra utilizaremos a @Relacao(mappedBy="NomeDaPrimeiraEntidade"); 
 - Nas associações unidirecionais, só precisamos utilizar a anotação de relacionamento em uma das entidades.
 - Se há uma classe MUITO simples, podemos usá-la somente como uma coleção, através da anotação @ElementCollection, e não será necessário criar uma classe entidade para ela. Ex: "O cliente tem telefone(com 1 campo: número), usaremos um atributo na classe Cliente com a anotação acima, sendo uma lista(ou Set(não deixa repetir valores)), e não será necessário criar outro arquivo, mas no banco de dados será criada uma nova tabela";
-  Na herança, adicionaremos, na classe mãe, a anotação @Inheritance(strategy=InheritanceType.JOINED/SINGLE_TABLE),  e somente isso.(O PRIMEIRO CRIA CLASSES SEPARADAS PARA AS FILHAS, E O SEGUNDO CRIA UMA SUPER CLASSE CONTENDO TUDO E O QUE NÃO FOR USADO FICA COMO NULL).
 - Para criar chaves primárias compostas, temos que criar uma classe separada contento as variáveis que são as chaves compostas, e a anotação @Embeddable, e cada variável contento a anotação ao de relacionamento. Voltando para a classe principal, adicionaremos uma variável com anotação @EmbeddedId.
 - Além do @Enumerated, há outra maneira: a variável enum sendo inteiro, mas quando formos adicionar no objeto, utilizaremos a classe enum, pois os getters e setters da classe fazem essa conversão. E no arquivo enum em si, utilizaremos construtores para guardar "variáveis" em cada tipo enum. Ex: todos os enums da classe seguindo essa estrutura: PessoaFisica(1, "Pessoa Fisica"). (Teria que ser criado as variáveis na classe enum, bem como o construtor do enum).

========== Módulo 3: implementação do modelo conceitual ========== 

- ResponseEntity é uma classe que pode ser usada como retorno de um método REST. Oferece métodos de status code(ok,created,accepted,notFound, badRequest,noContent), body e etc...
- Quando adicionamos um novo recursos, é de boa prática rest retornar a sua respectiva URI(URL de acesso ao recurso), através da classe URI:
URI uri = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(obj.getId()).toUri();
- Através da classe ExceptionHandler, podemos capturar excessões e tratá-las, da maneira que quisermos, criando uma classe com a anotação @ControllerAdvice e com métodos contendo o @ExceptionHandler;
- Para fazer validações, utilizaremos o BeanValidation do Java(implementado pelo Hibernste), adicionando anotações como @NotEmpty e @Lenght na classe modelo e o @Valid no controlador rest. Caso seja necessário uma validação customizada, a fazemos no servico;
- Para criar anotações de classes, temos que criar duas classes: uma que será a @interface(com um certo padrão que podemos copiar e colar) e a outra que será a sua implementação. Implementando a Co nstraintValidator<Nome, Classe> e sobrescrevendo o método isValid que retorna true ou false e adiciona os erros no context. A partir desse momento, a anotação @Valid do Controller vai depender deste método;
 - Sempre que tivermos mais de uma inserção no manco de dados em um método, devemos adicionar a anotação @Transactional para que todos aqueles inserts ocorram na mesma transação, otimizando a API;
 - Sempre que formos criar um método de consulta na interface repository, temos que adicionar a classe @Transactional(readOnly=true), para que não seja criada uma transação, otimizando a API.

========== Módulo 5: serviço de email ========== 

 - Temos que colocar umas configurações no application.properties que o framework precisa, entre elas o login e senha do seu email.
 - Temos duas maneiras diferentes de enviar emails: com HTML e sem HTML;
 - Sem HTML: criaremos um objeto do tipo SimpleMailMessage, que receberá as configurações do envio de email, tais como corpo do email, assunto, data, destinatário, remetente e etc... Depois que popularmos o objeto, usaremos uma classe chamada MailSender para enviar o email, através do método mailSender.send(simpleMailMessage);
 - Com HTML: criaremos um objeto do tipo MimeMessage, que precisa do JavaMailSender para ser instanciado. Depois, criaremos o objeto MimeMessageHelp, que servirá para popularmos as configurações do envio de email. Após isso, usaremos a classe JavaMailSender, com o objeto javaMailSender.send(mimeMessage), para enviar o email; 
 - OBS: na hora de popular o mimeMessageHelp setando o corpo do email(que é uma string), temos que usar a classe context, que servirá para transformarmos o arquivo HTML criado em string, além de ligar a variável do pedido, por exemplo, à variável usada no arquivo HTML, através do context.setVariable("variavel", variavel). Após isso, usaremos uma classe chamada TemplateEngine, com o método templateEngine.process("caminho do arquivo na pasta templates", context), que retorna o arquivo html em formato de string(para ser setada como corpo do email).

========== Módulo 6: autenticação e autorização com tokens JWT ========== 

 - SecurityConfig: recebe as anotações: @Configuration e @EnableWebSecurity; além do método configure(HttpSecurity http) para definir as configurações básicas;
 - Temos que criar duas implementações, uma para UserDetails("model do usuário") e outra para UserDetailsService(spbrescrevendo o método loadUserByUsername(String email), que verifica se o email existe e retorna a implementação do UserDetails;
 - No SecurityConfig, sobrescrever o método configure(AuthenticationManagerBuilder auth) para definir o userDetailsService e o tipo de codificação da senha(bCrypt);
 - Vamos criar um utilitários(JWTUtils), que receberá o método que vai gerar um token através do Jwts.builder().set...
 - Então, vamos criar um filtro de autenticação, que intercepta o login e verifica os dados, através do método attemptAuthentication(método não muito intuitivo. Se a autenticação der certo, o método successfulAuthentication, que foi sobrescrito, será chamado. Nele, o método de gerar o token será chamado, e este será adicionado no header da response;
 - Agora, temos que adicionar o filtro de autenticação no método configure(HttpSecurity http), do SecurityConfig:
http.addFilter(new JWTAuthenticationFilter(authenticationManager(), jwtUtil));
 - Portanto, se formos no endpoint "/login" e passar o email e a senha correta, receberemos na resposta o token que terá que ser usado no header das requisições que queremos fazer daqui em diante. Mas, para que ocorre a autorização do token nas requisições, preisamos criar o filtro de autorização;
  - Agora, temos que adicionar o filtro de autorização no método configure(HttpSecurity http), do SecurityConfig: 
http.addFilter(new JWTAuthorizationFilter(authenticationManager(), jwtUtil, userDetailsService));
 - No filtro de autorização, sobrescreveremos o método doFilterInternal, que vai pegar o token do header, fazer a validação através do método tokenValido(criado no JWTUtils), e se der certo, através de um comando, fará a autorização;
 - Para fazer autorizações para diferentes tipos de perfis criados para os clientes, temos que adicionar a anotação @EnableGlobalMethodSecurity(prePostEnabled = true) no SecurityConfig, e a anotação @PreAuthorize("hasAnyRole('PERFIL')") nos métodos do resource;
 - Para criar o RefreshToken, só precisamos criar um método no resource, que pega o usuário que está autenticado e cria um novo token para ele, chamando o método do JWTUtils, passando o username. Depois, é só adicionar o novo token no header;